# Pain Points and Suggested Improvements

## Project 1: [units_converter_extension](https://github.com/NCSU-S/units_converter_extension)
Talking about the unit conversion project repo, the whole project had a set of instructions that could quickly be followed. However, if a developer looks at it, he/she would question if it actually contains everything one would need to get it running in 2023. Issues faced here could be summarised under these brackets, i.e., lack of familiarity, documentation gaps, legacy code issues, technical debt, integrations, dependencies, and evolving requirements. When we inherit a project developed by someone else, we may not be familiar with the codebase and coding style and this makes it challenging to quickly understand and work with existing code.   

To start off with, the project does not mention that it is a Chrome extension and by looking at the name, one would not actually know that it is an extension. On further inspection, it can be inferred that it is a browser extension but it falls short in mentioning that it is supported only by ‘Google Chrome’. Modern-day developers use a vast array of different browsers and support for each one of them would have been appreciated. The project forces the user to work on Google Chrome. The documentation gap seems apparent since it does not clearly mention that they require Google Chrome. 
Integrations and dependencies include having npm and NodeJs installed. The version number is missing here and this plays a huge role in getting the project up and running. Different NodeJs versions support different libraries and not everything would function smoothly on newer versions. A common error that crept up was "Uncaught ReferenceError: module is not defined" and this typically occurs in JavaScript when you are trying to use the module object, which is part of the CommonJS or ES6 module system, in an environment that doesn't support it. We need to ensure here that we are working in the correct module system and also need to correctly identify the browser environment we are working in. Since the project was developed in 2020, the developers have not provided sufficient support for evolving environments and updates. 

The errors that crept up required us to correct existing code and although the codebase was modular, each function lacked the required documentation to make necessary changes. The auto-generated Jdocs were insufficient to interpret. Overall, the project could be run but due to the errors in code, not all features were working as expected. 

## Project 2: [TeachersPetBot](https://github.com/Ashwinshankar98/TeachersPetBot/)
In the endeavor to execute the project, a series of challenges unfolded, each underscoring key aspects of software engineering. One particularly prominent hurdle arose during the installation of essential packages or libraries. The project, which aimed to create a Discord bot with interactive components, necessitated the utilization of the `discord-components` library. This library, crucial for incorporating interactive elements like buttons and selects, proved elusive. The perplexing error message "`No matching distribution found for discord-components`" was a recurring roadblock.

The root of this conundrum was two-fold. Firstly, it appeared that the `discord-components` package was either not available on the Python Package Index (`PyPI`) or, if it was, it suffered from compatibility issues with the specific Python environment. This predicament exemplifies the dependency management intricacies that software engineers frequently grapple with. In the ever-evolving landscape of software development, the availability and compatibility of libraries can be fluid, necessitating a keen understanding of versioning and dependencies.

In an attempt to surmount this obstacle, I resorted to alternative sources for the `discord-components` package. This entailed installing the package directly from the project's GitHub repository. This approach, while sometimes effective in bypassing PyPI-related issues, proved fruitless in this instance. The continued failure to install the necessary library underscored the importance of robust development environments and the careful curation of dependencies.

The project, which should have seamlessly run and demonstrated sophisticated software engineering practices such as bot command handling, event-driven programming, and user interactions through Discord components, was ultimately hampered by the unresolved dependency issue. In software development, such challenges underscore the significance of thorough dependency management, version control, and a robust development environment. Addressing these hurdles often requires a combination of troubleshooting skills, community support, and adaptability to evolving libraries and frameworks, all essential aspects of modern software engineering.

## Project 3: [slash](https://github.com/NCSU-Group7-SE2021/slash)

We attempted to install the "slash" project but encountered issues due to unclear tools and dependency specifications. The project uses Python on the server-side and Node.js on the client-side, with needed dependencies listed in requirements.txt and package.json. Unfortunately, the required Python and Node.js versions were unspecified. When version for programming langauge or any framework is missing, user assumes that it is acceptable to run the code with the latest versions. We believe that this lead to compatibility problems.

While Python modules installed smoothly, installing Node.js packages via `npm install` resulted in a dependency conflict, particularly with the *react* package. To bypass this, we had to use the `--force` flag as suggested by the error message, silencing the error but generating a warning about potential mismatches. Additionally, the project offers installation through Docker. However, it lacked the client-side code where we faced the errors. Docker image is a great alternative to address the compatibility issues that may arise in the future. This project missed an opportunity by creating an end-to-end images containing both client and server code.

Upon addressing installation errors, we ran the Python server, but it displayed FastAPI docs on the index page. It wasn't clear whether this was the intended behavior, as the documentation lacked server startup instructions and error indicators. Subsequently, we attempted to run the Node.js client with `npm run start`, but it terminated due to an OpenSSL error. Even with online resources, we couldn't resolve this issue, causing us to abandon our **slash**  project installation efforts.

For future projects, we commit to providing comprehensive documentation, including red flag indicators for potential issues and clear indications of successful server operation. We commit to fully utilize Docker to address any potential version changes in future. We'll also supply additional references to assist users in installing required dependencies, ensuring a smoother experience for all users.


## Project 4: [ScheduleBot](https://github.com/SEProjGrp5/ScheduleBot.git)

As we attempted to run the Schedulebot which is a Python application that helps you calendarize events and work through a Discord bot, there were a few obstacles we dealt with.
Firstly, when aiming to run the requirements.txt, there were no versions specified for Python and discord. Assuming that the latest versions would work, we tried to run it which resulted in errors. Upon further discovery, the Discord version 1.0 worked better with the discord.py libraries that were used in the python code. he bot then worked smoothly, scheduling the events as per necessity. 

When attempting to establish the integration of Google calender with the bot, we encountered a hurdle where the system denied our request because of insufficient permissions. This issue was due to the complex authorization process required to access Google Calendar data. Navigating the OAuth 2.0 authentication flow, configuring API credentials, and managing scopes lead to errors in permissions management. Ensuring that the bot account and the associated Google API project have the necessary permissions, as well as correctly configuring the OAuth consent screen, became a critical task. It also demanded careful attention to privacy and security concerns, as dealing with calendar events involves sensitive information. 

A detailed documentation specifying the integration and use of the Geocoding API would have been a valuable enhancement making the process easier. Resolving these permission-related challenges required thorough documentation review and configuration adjustments to establish a secure and functional connection between the Discord bot and Google Calendar.
